{"version":3,"file":"static/js/6064.200b0c4a.chunk.js","mappings":"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","sources":["routing/site/physics/components/Optics/index.jsx"],"sourcesContent":["import React, { useState } from \"react\"\nimport styled from \"styled-components\"\nimport Draggable from \"react-draggable\"\n\nconst Canvas = styled.div`\n  width: 100%;\n  height: 80vh;\n  background: #f0f0f0;\n  position: relative;\n  overflow: hidden;\n`\n\nconst MirrorStyled = styled.div`\n  width: 10px;\n  height: 100px;\n  background: #000;\n  position: absolute;\n`\n\nconst LensStyled = styled.div`\n  width: 10px;\n  height: 100px;\n  background: rgba(0, 0, 255, 0.5);\n  position: absolute;\n`\n\nconst RayStyled = styled.div`\n  position: absolute;\n  width: 5px;\n  background: yellow;\n  height: ${(props) => props.length}px;\n  transform: rotate(${(props) => props.angle}deg);\n  transform-origin: top left;\n`\n\nconst Panel = styled.div`\n  width: 100%;\n  height: 20vh;\n  background: #333;\n  color: #fff;\n  display: flex;\n  justify-content: space-around;\n  align-items: center;\n  @media (max-width: 768px) {\n    flex-direction: column;\n    height: auto;\n  }\n`\n\nconst Button = styled.button`\n  background: #fff;\n  color: #333;\n  padding: 10px 20px;\n  border: none;\n  cursor: pointer;\n  margin: 5px;\n`\n\nconst Mirror = () => <MirrorStyled />\nconst Lens = () => <LensStyled />\n\nconst Ray = ({ startX, startY, endX, endY }) => {\n  const length = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2)\n  const angle = Math.atan2(endY - startY, endX - startX) * (180 / Math.PI)\n\n  return (\n    <RayStyled\n      style={{ top: startY, left: startX }}\n      angle={angle}\n      length={length}\n    />\n  )\n}\n\n// Function to calculate intersection point of a ray with an element\nconst calculateIntersection = (rayStart, rayEnd, element) => {\n  const { x: x1, y: y1 } = rayStart\n  const { x: x2, y: y2 } = rayEnd\n  const { x: x3, y: y3, width, height } = element\n\n  const denominator =\n    (x1 - x2) * (y3 - y3 + height) - (y1 - y2) * (x3 - x3 + width)\n  if (denominator === 0) return null\n\n  const t1 =\n    ((x1 - x3) * (y3 - y3 + height) - (y1 - y3) * (x3 - x3 + width)) /\n    denominator\n  const t2 = ((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denominator\n\n  if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {\n    return {\n      x: x1 + t1 * (x2 - x1),\n      y: y1 + t1 * (y2 - y1),\n    }\n  }\n  return null\n}\n\n// Function to calculate reflection or refraction of a ray at an element\nconst calculateReflectionOrRefraction = (ray, element) => {\n  const { width, height } = element\n  const { startX, startY, endX, endY } = ray\n\n  // Calculate normal vector of the element\n  const normalVector = {\n    x: height === 0 ? 1 : 0,\n    y: width === 0 ? 1 : 0,\n  }\n\n  // Calculate incident and reflected/refracted angles\n  const incidentAngle = Math.atan2(endY - startY, endX - startX)\n  const normalAngle = Math.atan2(normalVector.y, normalVector.x)\n  const angleOfIncidence = incidentAngle - normalAngle\n  const angleOfReflectionOrRefraction =\n    element.type === \"mirror\"\n      ? incidentAngle - 2 * angleOfIncidence\n      : incidentAngle + 2 * angleOfIncidence\n\n  // Calculate new endpoint based on angle of reflection/refraction\n  const length = ray.length\n  const newEndX = startX + length * Math.cos(angleOfReflectionOrRefraction)\n  const newEndY = startY + length * Math.sin(angleOfReflectionOrRefraction)\n\n  return {\n    ...ray,\n    endX: newEndX,\n    endY: newEndY,\n  }\n}\n\n// Function to check if a point is outside the canvas boundaries\nconst isOutsideCanvas = (x, y) => {\n  const canvasWidth = window.innerWidth\n  const canvasHeight = window.innerHeight\n  return x < 0 || x > canvasWidth || y < 0 || y > canvasHeight\n}\n\nconst calculateRay = (ray, elements) => {\n  let newRay = { ...ray }\n  let rayEndX = newRay.startX\n  let rayEndY = newRay.startY\n\n  for (let i = 0; i < 1000; i++) {\n    // Adjust maximum iterations as needed\n    const nextPoint = { x: rayEndX, y: rayEndY }\n\n    elements.forEach((element) => {\n      const intersection = calculateIntersection(\n        { x: newRay.startX, y: newRay.startY },\n        nextPoint,\n        element\n      )\n      if (intersection) {\n        newRay = calculateReflectionOrRefraction(newRay, element)\n        rayEndX = newRay.endX\n        rayEndY = newRay.endY\n      }\n    })\n\n    // Update ray length\n    newRay.length = Math.sqrt(\n      (newRay.endX - newRay.startX) ** 2 + (newRay.endY - newRay.startY) ** 2\n    )\n\n    // Break loop if ray has reached maximum length or reached canvas boundaries\n    if (\n      newRay.length >= ray.length ||\n      isOutsideCanvas(newRay.endX, newRay.endY)\n    ) {\n      break\n    }\n  }\n\n  return newRay\n}\n\nconst MirrorLensCanvas = ({ elements, rays, onDragElement, onDragRay }) => {\n  return (\n    <Canvas>\n      {elements.map((el, index) => (\n        <Draggable\n          key={index}\n          defaultPosition={{ x: el.x, y: el.y }}\n          onStop={(e, data) => onDragElement(index, data.x, data.y)}\n        >\n          <div style={{ position: \"absolute\", top: 0, left: 0 }}>\n            {el.type === \"mirror\" ? <Mirror /> : <Lens />}\n          </div>\n        </Draggable>\n      ))}\n      {rays.map((ray, index) => {\n        const calculatedRay = calculateRay(ray, elements)\n        return (\n          <Draggable\n            key={index}\n            defaultPosition={{\n              x: calculatedRay.startX,\n              y: calculatedRay.startY,\n            }}\n            onStop={(e, data) => onDragRay(index, data.x, data.y)}\n          >\n            <div style={{ position: \"absolute\", top: 0, left: 0 }}>\n              <Ray\n                startX={calculatedRay.startX}\n                startY={calculatedRay.startY}\n                endX={calculatedRay.endX}\n                endY={calculatedRay.endY}\n              />\n            </div>\n          </Draggable>\n        )\n      })}\n    </Canvas>\n  )\n}\n\nconst ControlPanel = ({ addElement, addRay }) => {\n  return (\n    <Panel>\n      <Button onClick={() => addElement(\"mirror\")}>Add Mirror</Button>\n      <Button onClick={() => addElement(\"lens\")}>Add Lens</Button>\n      <Button onClick={addRay}>Add Ray</Button>\n    </Panel>\n  )\n}\n\nconst AppContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  height: 100vh;\n`\n\nfunction App() {\n  const [elements, setElements] = useState([])\n  const [rays, setRays] = useState([])\n\n  const addElement = (type) => {\n    setElements([...elements, { type, x: 100, y: 100 }])\n  }\n\n  const onDragElement = (index, x, y) => {\n    const updatedElements = [...elements]\n    updatedElements[index] = { ...updatedElements[index], x, y }\n    setElements(updatedElements)\n  }\n\n  const onDragRay = (index, x, y) => {\n    const updatedRays = [...rays]\n    const draggedRay = updatedRays[index]\n\n    if (draggedRay) {\n      const dx = x - draggedRay.startX\n      const dy = y - draggedRay.startY\n\n      updatedRays[index] = {\n        ...draggedRay,\n        startX: x,\n        startY: y,\n        endX: draggedRay.endX + dx,\n        endY: draggedRay.endY + dy,\n      }\n\n      setRays(updatedRays)\n    }\n  }\n\n  const addRay = () => {\n    setRays([...rays, { startX: 200, startY: 100, endX: 200, endY: 300 }])\n  }\n\n  return (\n    <AppContainer>\n      <MirrorLensCanvas\n        elements={elements}\n        onDragElement={onDragElement}\n        rays={rays}\n        onDragRay={onDragRay}\n      />\n      <ControlPanel addElement={addElement} addRay={addRay} />\n    </AppContainer>\n  )\n}\n\nexport default App\n"],"names":["Canvas","styled","MirrorStyled","LensStyled","RayStyled","props","length","angle","Panel","Button","Mirror","_jsx","Lens","Ray","_ref","startX","startY","endX","endY","Math","sqrt","atan2","PI","style","top","left","calculateIntersection","rayStart","rayEnd","element","x","x1","y","y1","x2","y2","x3","y3","width","height","denominator","t1","t2","calculateReflectionOrRefraction","ray","normalVector","incidentAngle","angleOfIncidence","angleOfReflectionOrRefraction","type","newEndX","cos","newEndY","sin","isOutsideCanvas","canvasWidth","window","innerWidth","canvasHeight","innerHeight","MirrorLensCanvas","_ref2","elements","rays","onDragElement","onDragRay","_jsxs","children","map","el","index","Draggable","defaultPosition","onStop","e","data","position","calculatedRay","calculateRay","newRay","rayEndX","rayEndY","i","nextPoint","forEach","ControlPanel","_ref3","addElement","addRay","onClick","AppContainer","setElements","useState","setRays","updatedElements","updatedRays","draggedRay","dx","dy"],"sourceRoot":""}