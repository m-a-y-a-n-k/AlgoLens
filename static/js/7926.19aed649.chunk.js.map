{"version":3,"file":"static/js/7926.19aed649.chunk.js","mappings":"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","sources":["webpack://AlgoLens/./src/routing/site/algo/components/AStarPathfinding/AStarPathfinding.module.css?9e03","routing/site/algo/components/AStarPathfinding/index.jsx"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"container\":\"AStarPathfinding_container__T5b7E\",\"title\":\"AStarPathfinding_title__CO28l\",\"legend\":\"AStarPathfinding_legend__rwfyG\",\"legendItem\":\"AStarPathfinding_legendItem__n8jhK\",\"legendBox\":\"AStarPathfinding_legendBox__ZIio+\",\"controls\":\"AStarPathfinding_controls__nCmB6\",\"controlGroup\":\"AStarPathfinding_controlGroup__XjqqP\",\"slider\":\"AStarPathfinding_slider__5sBIo\",\"btnPrimary\":\"AStarPathfinding_btnPrimary__dr37B\",\"btnSecondary\":\"AStarPathfinding_btnSecondary__e0fd5\",\"stats\":\"AStarPathfinding_stats__NZNVb\",\"stat\":\"AStarPathfinding_stat__IWfuM\",\"statLabel\":\"AStarPathfinding_statLabel__QJfgg\",\"statValue\":\"AStarPathfinding_statValue__oGKoa\",\"gridContainer\":\"AStarPathfinding_gridContainer__O07xG\",\"grid\":\"AStarPathfinding_grid__pLS36\",\"row\":\"AStarPathfinding_row__drAIx\",\"cell\":\"AStarPathfinding_cell__gITm8\",\"empty\":\"AStarPathfinding_empty__o4tbD\",\"start\":\"AStarPathfinding_start__Z941h\",\"pulse\":\"AStarPathfinding_pulse__f1Z6i\",\"end\":\"AStarPathfinding_end__+cHf5\",\"wall\":\"AStarPathfinding_wall__K8cyM\",\"open\":\"AStarPathfinding_open__aPz57\",\"fadeIn\":\"AStarPathfinding_fadeIn__S5lcr\",\"closed\":\"AStarPathfinding_closed__3vbwG\",\"path\":\"AStarPathfinding_path__vxO3V\",\"pathReveal\":\"AStarPathfinding_pathReveal__kVSpg\",\"instructions\":\"AStarPathfinding_instructions__PR6db\"};","import React, { useState, useEffect, useRef } from \"react\"\nimport styles from \"./AStarPathfinding.module.css\"\n\nconst GRID_ROWS = 20\nconst GRID_COLS = 40\n\nconst CELL_TYPE = {\n  EMPTY: \"empty\",\n  START: \"start\",\n  END: \"end\",\n  WALL: \"wall\",\n  OPEN: \"open\",\n  CLOSED: \"closed\",\n  PATH: \"path\",\n}\n\nconst AStarPathfinding = () => {\n  const [grid, setGrid] = useState([])\n  const [start, setStart] = useState({ row: 5, col: 5 })\n  const [end, setEnd] = useState({ row: 14, col: 34 })\n  const [isDrawing, setIsDrawing] = useState(false)\n  const [isRunning, setIsRunning] = useState(false)\n  const [isComplete, setIsComplete] = useState(false)\n  const [speed, setSpeed] = useState(20)\n  const [stats, setStats] = useState({ nodesVisited: 0, pathLength: 0 })\n  const [drawMode, setDrawMode] = useState(\"wall\") // wall, start, end\n  const stopRef = useRef(false)\n\n  // Initialize grid\n  useEffect(() => {\n    initializeGrid()\n  }, [])\n\n  const initializeGrid = () => {\n    const newGrid = []\n    for (let row = 0; row < GRID_ROWS; row++) {\n      const currentRow = []\n      for (let col = 0; col < GRID_COLS; col++) {\n        currentRow.push({\n          row,\n          col,\n          type: CELL_TYPE.EMPTY,\n          f: Infinity,\n          g: Infinity,\n          h: 0,\n          parent: null,\n        })\n      }\n      newGrid.push(currentRow)\n    }\n    setGrid(newGrid)\n    setIsComplete(false)\n    setStats({ nodesVisited: 0, pathLength: 0 })\n  }\n\n  const heuristic = (node, end) => {\n    // Manhattan distance\n    return Math.abs(node.row - end.row) + Math.abs(node.col - end.col)\n  }\n\n  const getNeighbors = (grid, node) => {\n    const neighbors = []\n    const { row, col } = node\n    const directions = [\n      { r: -1, c: 0 }, // up\n      { r: 1, c: 0 }, // down\n      { r: 0, c: -1 }, // left\n      { r: 0, c: 1 }, // right\n    ]\n\n    directions.forEach(({ r, c }) => {\n      const newRow = row + r\n      const newCol = col + c\n      if (\n        newRow >= 0 &&\n        newRow < GRID_ROWS &&\n        newCol >= 0 &&\n        newCol < GRID_COLS\n      ) {\n        neighbors.push(grid[newRow][newCol])\n      }\n    })\n    return neighbors\n  }\n\n  const reconstructPath = (endNode) => {\n    const path = []\n    let current = endNode\n    while (current !== null) {\n      path.unshift(current)\n      current = current.parent\n    }\n    return path\n  }\n\n  const runAStar = async () => {\n    if (isRunning) return\n    setIsRunning(true)\n    setIsComplete(false)\n    stopRef.current = false\n\n    // Reset grid cells except walls, start, and end\n    const newGrid = grid.map((row) =>\n      row.map((cell) => ({\n        ...cell,\n        type:\n          cell.type === CELL_TYPE.WALL ||\n          (cell.row === start.row && cell.col === start.col) ||\n          (cell.row === end.row && cell.col === end.col)\n            ? cell.type\n            : CELL_TYPE.EMPTY,\n        f: Infinity,\n        g: Infinity,\n        h: 0,\n        parent: null,\n      }))\n    )\n\n    const startNode = newGrid[start.row][start.col]\n    const endNode = newGrid[end.row][end.col]\n\n    startNode.g = 0\n    startNode.h = heuristic(startNode, endNode)\n    startNode.f = startNode.g + startNode.h\n\n    const openSet = [startNode]\n    const closedSet = new Set()\n    let nodesVisited = 0\n\n    while (openSet.length > 0) {\n      if (stopRef.current) {\n        setIsRunning(false)\n        return\n      }\n\n      // Find node with lowest f score\n      openSet.sort((a, b) => a.f - b.f)\n      const current = openSet.shift()\n\n      // Reached the end\n      if (current.row === endNode.row && current.col === endNode.col) {\n        const path = reconstructPath(current)\n        // Animate path\n        for (const node of path) {\n          if (\n            node.row !== start.row ||\n            node.col !== start.col ||\n            node.row !== end.row ||\n            node.col !== end.col\n          ) {\n            newGrid[node.row][node.col].type = CELL_TYPE.PATH\n            setGrid([...newGrid])\n            await new Promise((resolve) => setTimeout(resolve, 50 - speed))\n          }\n        }\n        setStats({ nodesVisited, pathLength: path.length - 1 })\n        setIsComplete(true)\n        setIsRunning(false)\n        return\n      }\n\n      closedSet.add(`${current.row},${current.col}`)\n      if (current.row !== start.row || current.col !== start.col) {\n        newGrid[current.row][current.col].type = CELL_TYPE.CLOSED\n      }\n      nodesVisited++\n\n      const neighbors = getNeighbors(newGrid, current)\n\n      for (const neighbor of neighbors) {\n        if (\n          neighbor.type === CELL_TYPE.WALL ||\n          closedSet.has(`${neighbor.row},${neighbor.col}`)\n        ) {\n          continue\n        }\n\n        const tentativeG = current.g + 1\n\n        if (tentativeG < neighbor.g) {\n          neighbor.parent = current\n          neighbor.g = tentativeG\n          neighbor.h = heuristic(neighbor, endNode)\n          neighbor.f = neighbor.g + neighbor.h\n\n          if (\n            !openSet.find(\n              (n) => n.row === neighbor.row && n.col === neighbor.col\n            )\n          ) {\n            openSet.push(neighbor)\n            if (neighbor.row !== end.row || neighbor.col !== end.col) {\n              newGrid[neighbor.row][neighbor.col].type = CELL_TYPE.OPEN\n            }\n          }\n        }\n      }\n\n      setGrid([...newGrid])\n      setStats({ nodesVisited, pathLength: 0 })\n      await new Promise((resolve) => setTimeout(resolve, 50 - speed))\n    }\n\n    // No path found\n    setIsComplete(true)\n    setIsRunning(false)\n    alert(\"No path found!\")\n  }\n\n  const handleMouseDown = (row, col) => {\n    setIsDrawing(true)\n    handleCellClick(row, col)\n  }\n\n  const handleMouseEnter = (row, col) => {\n    if (isDrawing) {\n      handleCellClick(row, col)\n    }\n  }\n\n  const handleMouseUp = () => {\n    setIsDrawing(false)\n  }\n\n  const handleCellClick = (row, col) => {\n    if (isRunning) return\n\n    const newGrid = [...grid]\n    const cell = newGrid[row][col]\n\n    if (drawMode === \"wall\") {\n      // Don't allow walls on start or end\n      if (\n        (row === start.row && col === start.col) ||\n        (row === end.row && col === end.col)\n      ) {\n        return\n      }\n      cell.type =\n        cell.type === CELL_TYPE.WALL ? CELL_TYPE.EMPTY : CELL_TYPE.WALL\n    } else if (drawMode === \"start\") {\n      // Clear old start\n      if (grid[start.row][start.col].type !== CELL_TYPE.WALL) {\n        newGrid[start.row][start.col].type = CELL_TYPE.EMPTY\n      }\n      setStart({ row, col })\n      cell.type = CELL_TYPE.EMPTY\n    } else if (drawMode === \"end\") {\n      // Clear old end\n      if (grid[end.row][end.col].type !== CELL_TYPE.WALL) {\n        newGrid[end.row][end.col].type = CELL_TYPE.EMPTY\n      }\n      setEnd({ row, col })\n      cell.type = CELL_TYPE.EMPTY\n    }\n\n    setGrid(newGrid)\n  }\n\n  const generateMaze = () => {\n    if (isRunning) return\n    const newGrid = [...grid]\n\n    // Random maze generation\n    for (let row = 0; row < GRID_ROWS; row++) {\n      for (let col = 0; col < GRID_COLS; col++) {\n        if (\n          (row === start.row && col === start.col) ||\n          (row === end.row && col === end.col)\n        ) {\n          continue\n        }\n        newGrid[row][col].type =\n          Math.random() < 0.3 ? CELL_TYPE.WALL : CELL_TYPE.EMPTY\n      }\n    }\n    setGrid(newGrid)\n  }\n\n  const stopAlgorithm = () => {\n    stopRef.current = true\n  }\n\n  const getCellClass = (cell) => {\n    if (cell.row === start.row && cell.col === start.col) return styles.start\n    if (cell.row === end.row && cell.col === end.col) return styles.end\n\n    switch (cell.type) {\n      case CELL_TYPE.WALL:\n        return styles.wall\n      case CELL_TYPE.OPEN:\n        return styles.open\n      case CELL_TYPE.CLOSED:\n        return styles.closed\n      case CELL_TYPE.PATH:\n        return styles.path\n      default:\n        return styles.empty\n    }\n  }\n\n  return (\n    <div className={styles.container}>\n      <h1 className={styles.title}>A* Pathfinding Algorithm 🎯</h1>\n\n      {/* Legend */}\n      <div className={styles.legend}>\n        <div className={styles.legendItem}>\n          <div className={`${styles.legendBox} ${styles.start}`} />\n          <span>Start</span>\n        </div>\n        <div className={styles.legendItem}>\n          <div className={`${styles.legendBox} ${styles.end}`} />\n          <span>End</span>\n        </div>\n        <div className={styles.legendItem}>\n          <div className={`${styles.legendBox} ${styles.wall}`} />\n          <span>Wall</span>\n        </div>\n        <div className={styles.legendItem}>\n          <div className={`${styles.legendBox} ${styles.open}`} />\n          <span>Open Set</span>\n        </div>\n        <div className={styles.legendItem}>\n          <div className={`${styles.legendBox} ${styles.closed}`} />\n          <span>Closed Set</span>\n        </div>\n        <div className={styles.legendItem}>\n          <div className={`${styles.legendBox} ${styles.path}`} />\n          <span>Path</span>\n        </div>\n      </div>\n\n      {/* Controls */}\n      <div className={styles.controls}>\n        <div className={styles.controlGroup}>\n          <label>Draw Mode:</label>\n          <select\n            value={drawMode}\n            onChange={(e) => setDrawMode(e.target.value)}\n            disabled={isRunning}\n          >\n            <option value=\"wall\">Wall</option>\n            <option value=\"start\">Start Point</option>\n            <option value=\"end\">End Point</option>\n          </select>\n        </div>\n\n        <div className={styles.controlGroup}>\n          <label>Speed:</label>\n          <input\n            type=\"range\"\n            min=\"0\"\n            max=\"45\"\n            value={speed}\n            onChange={(e) => setSpeed(Number(e.target.value))}\n            className={styles.slider}\n          />\n        </div>\n\n        <button\n          onClick={runAStar}\n          disabled={isRunning}\n          className={styles.btnPrimary}\n        >\n          {isRunning ? \"Running...\" : \"Run A*\"}\n        </button>\n\n        <button\n          onClick={stopAlgorithm}\n          disabled={!isRunning}\n          className={styles.btnSecondary}\n        >\n          Stop\n        </button>\n\n        <button\n          onClick={generateMaze}\n          disabled={isRunning}\n          className={styles.btnSecondary}\n        >\n          Generate Maze\n        </button>\n\n        <button\n          onClick={initializeGrid}\n          disabled={isRunning}\n          className={styles.btnSecondary}\n        >\n          Clear Grid\n        </button>\n      </div>\n\n      {/* Stats */}\n      <div className={styles.stats}>\n        <div className={styles.stat}>\n          <span className={styles.statLabel}>Nodes Visited:</span>\n          <span className={styles.statValue}>{stats.nodesVisited}</span>\n        </div>\n        {isComplete && stats.pathLength > 0 && (\n          <div className={styles.stat}>\n            <span className={styles.statLabel}>Path Length:</span>\n            <span className={styles.statValue}>{stats.pathLength}</span>\n          </div>\n        )}\n      </div>\n\n      {/* Grid */}\n      <div className={styles.gridContainer} onMouseLeave={handleMouseUp}>\n        <div className={styles.grid}>\n          {grid.map((row, rowIdx) => (\n            <div key={rowIdx} className={styles.row}>\n              {row.map((cell, colIdx) => (\n                <div\n                  key={`${rowIdx}-${colIdx}`}\n                  className={`${styles.cell} ${getCellClass(cell)}`}\n                  onMouseDown={() => handleMouseDown(rowIdx, colIdx)}\n                  onMouseEnter={() => handleMouseEnter(rowIdx, colIdx)}\n                  onMouseUp={handleMouseUp}\n                />\n              ))}\n            </div>\n          ))}\n        </div>\n      </div>\n\n      {/* Instructions */}\n      <div className={styles.instructions}>\n        <h3>How to use:</h3>\n        <ul>\n          <li>Select &quot;Wall&quot; mode and click/drag to draw walls</li>\n          <li>\n            Select &quot;Start Point&quot; or &quot;End Point&quot; mode to\n            reposition them\n          </li>\n          <li>Click &quot;Generate Maze&quot; for a random maze</li>\n          <li>\n            Click &quot;Run A*&quot; to watch the algorithm find the shortest\n            path\n          </li>\n          <li>\n            A* uses f(n) = g(n) + h(n) where g is cost from start, h is\n            heuristic to goal\n          </li>\n        </ul>\n      </div>\n    </div>\n  )\n}\n\nexport default AStarPathfinding\n"],"names":["CELL_TYPE","AStarPathfinding","grid","setGrid","useState","start","setStart","row","col","end","setEnd","isDrawing","setIsDrawing","isRunning","setIsRunning","isComplete","setIsComplete","speed","setSpeed","stats","setStats","nodesVisited","pathLength","drawMode","setDrawMode","stopRef","useRef","useEffect","initializeGrid","newGrid","currentRow","push","type","f","Infinity","g","h","parent","heuristic","node","Math","abs","getNeighbors","neighbors","r","c","forEach","_ref","newRow","newCol","reconstructPath","endNode","path","current","unshift","handleMouseUp","handleCellClick","cell","getCellClass","styles","_jsxs","className","children","_jsx","concat","value","onChange","e","target","disabled","min","max","Number","onClick","async","map","_objectSpread","startNode","openSet","closedSet","Set","length","sort","a","b","shift","Promise","resolve","setTimeout","add","neighbor","has","tentativeG","find","n","alert","stopAlgorithm","generateMaze","random","onMouseLeave","rowIdx","colIdx","onMouseDown","handleMouseDown","onMouseEnter","handleMouseEnter","onMouseUp"],"sourceRoot":""}