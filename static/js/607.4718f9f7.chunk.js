"use strict";(self.webpackChunkAlgoLens=self.webpackChunkAlgoLens||[]).push([[607],{10607:(e,s,l)=>{l.r(s),l.d(s,{default:()=>Z});var t=l(72791);const a="RedBlackTree_container__9oBjZ",r="RedBlackTree_title__+7hd1",n="RedBlackTree_description__DEx4V",i="RedBlackTree_controls__uyPWF",o="RedBlackTree_inputGroup__WzjrR",c="RedBlackTree_input__IXspC",d="RedBlackTree_btnPrimary__hYpCM",h="RedBlackTree_btnSecondary__2DNvO",p="RedBlackTree_btnDanger__qukU1",u="RedBlackTree_btnNav__DY5OH",m="RedBlackTree_animationControls__j5zqW",_="RedBlackTree_stepCounter__ezlss",x="RedBlackTree_stepMessage__WnJZW",g="RedBlackTree_legend__MU8vq",j="RedBlackTree_legendItem__ybGBZ",v="RedBlackTree_legendBox__-iRDl",N="RedBlackTree_legendRed__KRXsb",k="RedBlackTree_legendBlack__WM8d+",R="RedBlackTree_legendHighlight__vWt-F",B="RedBlackTree_section__J48rt",f="RedBlackTree_emptyMessage__wmwj3",T="RedBlackTree_treeContainer__7hKPY",y="RedBlackTree_treeSvg__LN61X",C="RedBlackTree_treeLine__3dzsL",S="RedBlackTree_redNode__wk394",b="RedBlackTree_blackNode__HDR6t",L="RedBlackTree_highlighted__32Hj6",$="RedBlackTree_nodeText__aQCzj",A="RedBlackTree_propertiesGrid__aCIhE",w="RedBlackTree_propertyCard__KMS-j",K="RedBlackTree_propertyNumber__kB3Xb",D="RedBlackTree_complexityGrid__sI4NZ",P="RedBlackTree_complexityCard__YOyBc",E="RedBlackTree_complexity__Ro7-n",M="RedBlackTree_complexityNote__2i6zL",O="RedBlackTree_explanation__f5jjZ",W="RedBlackTree_note__e99zr";var G=l(80184);const I="red",z="black";class U{constructor(e){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:I;this.value=e,this.color=s,this.left=null,this.right=null,this.parent=null}}class H{constructor(){this.root=null,this.animationSteps=[]}rotateLeft(e){this.animationSteps.push({type:"rotate-left",node:e.value,message:`Left rotation on node ${e.value}`});const s=e.right;e.right=s.left,null!==s.left&&(s.left.parent=e),s.parent=e.parent,null===e.parent?this.root=s:e===e.parent.left?e.parent.left=s:e.parent.right=s,s.left=e,e.parent=s}rotateRight(e){this.animationSteps.push({type:"rotate-right",node:e.value,message:`Right rotation on node ${e.value}`});const s=e.left;e.left=s.right,null!==s.right&&(s.right.parent=e),s.parent=e.parent,null===e.parent?this.root=s:e===e.parent.right?e.parent.right=s:e.parent.left=s,s.right=e,e.parent=s}fixViolation(e){let s=null,l=null;for(;e!==this.root&&e.color===I&&e.parent.color===I;)if(s=e.parent,l=s.parent,s===l.left){const t=l.right;if(null!==t&&t.color===I)this.animationSteps.push({type:"recolor",nodes:[l.value,s.value,t.value],message:`Recoloring: GP(${l.value}) RED, P(${s.value}) BLACK, U(${t.value}) BLACK`}),l.color=I,s.color=z,t.color=z,e=l;else{e===s.right&&(this.rotateLeft(s),s=(e=s).parent),this.animationSteps.push({type:"recolor",nodes:[s.value,l.value],message:`Recoloring and rotating: P(${s.value}) BLACK, GP(${l.value}) RED`}),this.rotateRight(l);const t=s.color;s.color=l.color,l.color=t,e=s}}else{const t=l.left;if(null!==t&&t.color===I)this.animationSteps.push({type:"recolor",nodes:[l.value,s.value,t.value],message:`Recoloring: GP(${l.value}) RED, P(${s.value}) BLACK, U(${t.value}) BLACK`}),l.color=I,s.color=z,t.color=z,e=l;else{e===s.left&&(this.rotateRight(s),s=(e=s).parent),this.animationSteps.push({type:"recolor",nodes:[s.value,l.value],message:`Recoloring and rotating: P(${s.value}) BLACK, GP(${l.value}) RED`}),this.rotateLeft(l);const t=s.color;s.color=l.color,l.color=t,e=s}}this.root.color=z}insert(e){this.animationSteps=[];const s=new U(e);if(this.animationSteps.push({type:"insert",node:e,message:`Inserting ${e} as RED node`}),null===this.root)return this.root=s,this.root.color=z,this.animationSteps.push({type:"root",node:e,message:`${e} is root, changing to BLACK`}),this.animationSteps;let l=this.root,t=null;for(;null!==l;)if(t=l,e<l.value)l=l.left;else{if(!(e>l.value))return[];l=l.right}return s.parent=t,e<t.value?t.left=s:t.right=s,null===s.parent.parent||this.fixViolation(s),this.animationSteps}clone(){const e=new H;return e.root=this.cloneNode(this.root,null),e}cloneNode(e,s){if(null===e)return null;const l=new U(e.value,e.color);return l.parent=s,l.left=this.cloneNode(e.left,l),l.right=this.cloneNode(e.right,l),l}}const Z=()=>{const[e,s]=(0,t.useState)(new H),[l,z]=(0,t.useState)(""),[U,Z]=(0,t.useState)([]),[V,X]=(0,t.useState)(-1),[Y,q]=(0,t.useState)([]),F=()=>{if(!l.trim())return;const t=parseInt(l,10);if(isNaN(t))return;const a=e.insert(t);s(e.clone()),Z(a),X(0),z(""),a.length>0&&J(a[0])},J=e=>{"recolor"===e.type&&e.nodes?q(e.nodes):void 0!==e.node&&q([e.node])},Q=(e,s,l,t,a)=>{if(!e)return null;const r=a/Math.pow(2,t+1),n=[],i=Y.includes(e.value);if(e.left){const i=s-r,o=l+80;n.push((0,G.jsx)("line",{x1:s,y1:l+28,x2:i,y2:o-28,className:C,strokeWidth:"3"},`left-line-${e.value}`)),n.push(...Q(e.left,i,o,t+1,a))}if(e.right){const i=s+r,o=l+80;n.push((0,G.jsx)("line",{x1:s,y1:l+28,x2:i,y2:o-28,className:C,strokeWidth:"3"},`right-line-${e.value}`)),n.push(...Q(e.right,i,o,t+1,a))}const o=e.color===I?S:b;return n.push((0,G.jsxs)("g",{children:[(0,G.jsx)("circle",{cx:s,cy:l,r:28,className:`${o} ${i?L:""}`}),(0,G.jsx)("text",{x:s,y:l+6,textAnchor:"middle",className:$,children:e.value})]},`node-${e.value}`)),n},ee=e=>e?1+Math.max(ee(e.left),ee(e.right)):0,se=ee(e.root),le=Math.max(400,90*se+50),te=V>=0&&V<U.length?U[V]:null;return(0,G.jsxs)("div",{className:a,children:[(0,G.jsx)("h1",{className:r,children:"Red-Black Tree Visualization \ud83d\udd34\u26ab"}),(0,G.jsx)("div",{className:n,children:(0,G.jsx)("p",{children:"A Red-Black Tree is a self-balancing binary search tree where each node has a color (red or black) and follows specific properties to maintain O(log n) operations."})}),(0,G.jsxs)("div",{className:i,children:[(0,G.jsxs)("div",{className:o,children:[(0,G.jsx)("input",{type:"number",value:l,onChange:e=>z(e.target.value),placeholder:"Enter value",className:c,onKeyPress:e=>"Enter"===e.key&&F()}),(0,G.jsx)("button",{onClick:F,className:d,children:"Insert"})]}),(0,G.jsx)("button",{onClick:()=>{const e=new H;[10,20,30,15,25,5,1].forEach((s=>e.insert(s))),s(e.clone()),Z([]),X(-1),q([])},className:h,children:"Load Sample"}),(0,G.jsx)("button",{onClick:()=>{s(new H),Z([]),X(-1),q([])},className:p,children:"Clear Tree"})]}),U.length>0&&(0,G.jsxs)("div",{className:m,children:[(0,G.jsx)("button",{onClick:()=>{if(V>0){const e=V-1;X(e),J(U[e])}},disabled:V<=0,className:u,children:"\u2190 Previous"}),(0,G.jsxs)("span",{className:_,children:["Step ",V+1," of ",U.length]}),(0,G.jsx)("button",{onClick:()=>{if(V<U.length-1){const e=V+1;X(e),J(U[e])}},disabled:V>=U.length-1,className:u,children:"Next \u2192"}),(0,G.jsx)("button",{onClick:()=>{q([])},className:u,children:"Clear Highlight"})]}),te&&(0,G.jsxs)("div",{className:x,children:[(0,G.jsxs)("strong",{children:["Step ",V+1,":"]})," ",te.message]}),(0,G.jsxs)("div",{className:g,children:[(0,G.jsxs)("div",{className:j,children:[(0,G.jsx)("div",{className:`${v} ${N}`}),(0,G.jsx)("span",{children:"Red Node"})]}),(0,G.jsxs)("div",{className:j,children:[(0,G.jsx)("div",{className:`${v} ${k}`}),(0,G.jsx)("span",{children:"Black Node"})]}),(0,G.jsxs)("div",{className:j,children:[(0,G.jsx)("div",{className:`${v} ${R}`}),(0,G.jsx)("span",{children:"Highlighted"})]})]}),(0,G.jsxs)("div",{className:B,children:[(0,G.jsx)("h3",{children:"Tree Structure"}),e.root?(0,G.jsx)("div",{className:T,children:(0,G.jsx)("svg",{width:"900",height:le,className:y,children:Q(e.root,450,40,0,450)})}):(0,G.jsx)("p",{className:f,children:"Tree is empty. Add some nodes!"})]}),(0,G.jsxs)("div",{className:B,children:[(0,G.jsx)("h3",{children:"Red-Black Tree Properties"}),(0,G.jsxs)("div",{className:A,children:[(0,G.jsxs)("div",{className:w,children:[(0,G.jsx)("div",{className:K,children:"1"}),(0,G.jsx)("p",{children:"Every node is either RED or BLACK"})]}),(0,G.jsxs)("div",{className:w,children:[(0,G.jsx)("div",{className:K,children:"2"}),(0,G.jsx)("p",{children:"The root is always BLACK"})]}),(0,G.jsxs)("div",{className:w,children:[(0,G.jsx)("div",{className:K,children:"3"}),(0,G.jsx)("p",{children:"All NULL leaves are considered BLACK"})]}),(0,G.jsxs)("div",{className:w,children:[(0,G.jsx)("div",{className:K,children:"4"}),(0,G.jsx)("p",{children:"Red node cannot have red children (no two consecutive red nodes)"})]}),(0,G.jsxs)("div",{className:w,children:[(0,G.jsx)("div",{className:K,children:"5"}),(0,G.jsx)("p",{children:"Every path from root to NULL has the same number of black nodes (Black Height)"})]})]})]}),(0,G.jsxs)("div",{className:B,children:[(0,G.jsx)("h3",{children:"Operations & Time Complexity"}),(0,G.jsxs)("div",{className:D,children:[(0,G.jsxs)("div",{className:P,children:[(0,G.jsx)("h4",{children:"Search"}),(0,G.jsx)("p",{className:E,children:"O(log n)"}),(0,G.jsx)("p",{className:M,children:"Same as BST"})]}),(0,G.jsxs)("div",{className:P,children:[(0,G.jsx)("h4",{children:"Insert"}),(0,G.jsx)("p",{className:E,children:"O(log n)"}),(0,G.jsx)("p",{className:M,children:"BST insert + rebalancing"})]}),(0,G.jsxs)("div",{className:P,children:[(0,G.jsx)("h4",{children:"Delete"}),(0,G.jsx)("p",{className:E,children:"O(log n)"}),(0,G.jsx)("p",{className:M,children:"BST delete + rebalancing"})]})]})]}),(0,G.jsxs)("div",{className:O,children:[(0,G.jsx)("h3",{children:"Real-World Applications:"}),(0,G.jsxs)("ul",{children:[(0,G.jsxs)("li",{children:[(0,G.jsx)("strong",{children:"Java TreeMap & TreeSet:"})," Standard library implementations"]}),(0,G.jsxs)("li",{children:[(0,G.jsx)("strong",{children:"C++ STL map & set:"})," Often implemented as Red-Black Trees"]}),(0,G.jsxs)("li",{children:[(0,G.jsx)("strong",{children:"Linux Kernel:"})," Used in process scheduling (Completely Fair Scheduler)"]}),(0,G.jsxs)("li",{children:[(0,G.jsx)("strong",{children:"Database Indexing:"})," Alternative to B-trees for in-memory indexes"]}),(0,G.jsxs)("li",{children:[(0,G.jsx)("strong",{children:"Computational Geometry:"})," Used in various geometric algorithms"]})]}),(0,G.jsxs)("div",{className:W,children:[(0,G.jsx)("strong",{children:"Note:"})," Red-Black Trees guarantee O(log n) time for all operations by maintaining balanced height through rotations and color changes."]})]})]})}}}]);
//# sourceMappingURL=607.4718f9f7.chunk.js.map