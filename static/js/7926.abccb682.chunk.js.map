{"version":3,"file":"static/js/7926.abccb682.chunk.js","mappings":"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","sources":["webpack://AlgoLens/./src/routing/site/algo/components/AStarPathfinding/AStarPathfinding.module.css?9e03","routing/site/algo/components/AStarPathfinding/index.jsx"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"container\":\"AStarPathfinding_container__jixWT\",\"title\":\"AStarPathfinding_title__8d3Gw\",\"legend\":\"AStarPathfinding_legend__1Oy2M\",\"legendItem\":\"AStarPathfinding_legendItem__0t72u\",\"legendBox\":\"AStarPathfinding_legendBox__+JAYR\",\"controls\":\"AStarPathfinding_controls__qycQK\",\"controlGroup\":\"AStarPathfinding_controlGroup__Dzp1g\",\"slider\":\"AStarPathfinding_slider__0V7WZ\",\"btnPrimary\":\"AStarPathfinding_btnPrimary__xGFfb\",\"btnSecondary\":\"AStarPathfinding_btnSecondary__4oWw7\",\"stats\":\"AStarPathfinding_stats__1r-JA\",\"stat\":\"AStarPathfinding_stat__-dWbu\",\"statLabel\":\"AStarPathfinding_statLabel__PRby0\",\"statValue\":\"AStarPathfinding_statValue__G8PEV\",\"gridContainer\":\"AStarPathfinding_gridContainer__ApExy\",\"grid\":\"AStarPathfinding_grid__jBqQM\",\"row\":\"AStarPathfinding_row__Gt7Lp\",\"cell\":\"AStarPathfinding_cell__e7aV2\",\"empty\":\"AStarPathfinding_empty__v7V0A\",\"start\":\"AStarPathfinding_start__SNk1Q\",\"pulse\":\"AStarPathfinding_pulse__8itXw\",\"end\":\"AStarPathfinding_end__PmQQ-\",\"wall\":\"AStarPathfinding_wall__ApV3Y\",\"open\":\"AStarPathfinding_open__MgH9L\",\"fadeIn\":\"AStarPathfinding_fadeIn__ifbGv\",\"closed\":\"AStarPathfinding_closed__+lfOZ\",\"path\":\"AStarPathfinding_path__ehOk+\",\"pathReveal\":\"AStarPathfinding_pathReveal__nQIlo\",\"instructions\":\"AStarPathfinding_instructions__a6MxI\"};","import React, { useState, useEffect, useRef } from \"react\"\r\nimport styles from \"./AStarPathfinding.module.css\"\r\n\r\nconst GRID_ROWS = 20\r\nconst GRID_COLS = 40\r\n\r\nconst CELL_TYPE = {\r\n  EMPTY: \"empty\",\r\n  START: \"start\",\r\n  END: \"end\",\r\n  WALL: \"wall\",\r\n  OPEN: \"open\",\r\n  CLOSED: \"closed\",\r\n  PATH: \"path\",\r\n}\r\n\r\nconst AStarPathfinding = () => {\r\n  const [grid, setGrid] = useState([])\r\n  const [start, setStart] = useState({ row: 5, col: 5 })\r\n  const [end, setEnd] = useState({ row: 14, col: 34 })\r\n  const [isDrawing, setIsDrawing] = useState(false)\r\n  const [isRunning, setIsRunning] = useState(false)\r\n  const [isComplete, setIsComplete] = useState(false)\r\n  const [speed, setSpeed] = useState(20)\r\n  const [stats, setStats] = useState({ nodesVisited: 0, pathLength: 0 })\r\n  const [drawMode, setDrawMode] = useState(\"wall\") // wall, start, end\r\n  const stopRef = useRef(false)\r\n\r\n  // Initialize grid\r\n  useEffect(() => {\r\n    initializeGrid()\r\n  }, [])\r\n\r\n  const initializeGrid = () => {\r\n    const newGrid = []\r\n    for (let row = 0; row < GRID_ROWS; row++) {\r\n      const currentRow = []\r\n      for (let col = 0; col < GRID_COLS; col++) {\r\n        currentRow.push({\r\n          row,\r\n          col,\r\n          type: CELL_TYPE.EMPTY,\r\n          f: Infinity,\r\n          g: Infinity,\r\n          h: 0,\r\n          parent: null,\r\n        })\r\n      }\r\n      newGrid.push(currentRow)\r\n    }\r\n    setGrid(newGrid)\r\n    setIsComplete(false)\r\n    setStats({ nodesVisited: 0, pathLength: 0 })\r\n  }\r\n\r\n  const heuristic = (node, end) => {\r\n    // Manhattan distance\r\n    return Math.abs(node.row - end.row) + Math.abs(node.col - end.col)\r\n  }\r\n\r\n  const getNeighbors = (grid, node) => {\r\n    const neighbors = []\r\n    const { row, col } = node\r\n    const directions = [\r\n      { r: -1, c: 0 }, // up\r\n      { r: 1, c: 0 }, // down\r\n      { r: 0, c: -1 }, // left\r\n      { r: 0, c: 1 }, // right\r\n    ]\r\n\r\n    directions.forEach(({ r, c }) => {\r\n      const newRow = row + r\r\n      const newCol = col + c\r\n      if (\r\n        newRow >= 0 &&\r\n        newRow < GRID_ROWS &&\r\n        newCol >= 0 &&\r\n        newCol < GRID_COLS\r\n      ) {\r\n        neighbors.push(grid[newRow][newCol])\r\n      }\r\n    })\r\n    return neighbors\r\n  }\r\n\r\n  const reconstructPath = (endNode) => {\r\n    const path = []\r\n    let current = endNode\r\n    while (current !== null) {\r\n      path.unshift(current)\r\n      current = current.parent\r\n    }\r\n    return path\r\n  }\r\n\r\n  const runAStar = async () => {\r\n    if (isRunning) return\r\n    setIsRunning(true)\r\n    setIsComplete(false)\r\n    stopRef.current = false\r\n\r\n    // Reset grid cells except walls, start, and end\r\n    const newGrid = grid.map((row) =>\r\n      row.map((cell) => ({\r\n        ...cell,\r\n        type:\r\n          cell.type === CELL_TYPE.WALL ||\r\n          (cell.row === start.row && cell.col === start.col) ||\r\n          (cell.row === end.row && cell.col === end.col)\r\n            ? cell.type\r\n            : CELL_TYPE.EMPTY,\r\n        f: Infinity,\r\n        g: Infinity,\r\n        h: 0,\r\n        parent: null,\r\n      }))\r\n    )\r\n\r\n    const startNode = newGrid[start.row][start.col]\r\n    const endNode = newGrid[end.row][end.col]\r\n\r\n    startNode.g = 0\r\n    startNode.h = heuristic(startNode, endNode)\r\n    startNode.f = startNode.g + startNode.h\r\n\r\n    const openSet = [startNode]\r\n    const closedSet = new Set()\r\n    let nodesVisited = 0\r\n\r\n    while (openSet.length > 0) {\r\n      if (stopRef.current) {\r\n        setIsRunning(false)\r\n        return\r\n      }\r\n\r\n      // Find node with lowest f score\r\n      openSet.sort((a, b) => a.f - b.f)\r\n      const current = openSet.shift()\r\n\r\n      // Reached the end\r\n      if (current.row === endNode.row && current.col === endNode.col) {\r\n        const path = reconstructPath(current)\r\n        // Animate path\r\n        for (const node of path) {\r\n          if (\r\n            node.row !== start.row ||\r\n            node.col !== start.col ||\r\n            node.row !== end.row ||\r\n            node.col !== end.col\r\n          ) {\r\n            newGrid[node.row][node.col].type = CELL_TYPE.PATH\r\n            setGrid([...newGrid])\r\n            await new Promise((resolve) => setTimeout(resolve, 50 - speed))\r\n          }\r\n        }\r\n        setStats({ nodesVisited, pathLength: path.length - 1 })\r\n        setIsComplete(true)\r\n        setIsRunning(false)\r\n        return\r\n      }\r\n\r\n      closedSet.add(`${current.row},${current.col}`)\r\n      if (current.row !== start.row || current.col !== start.col) {\r\n        newGrid[current.row][current.col].type = CELL_TYPE.CLOSED\r\n      }\r\n      nodesVisited++\r\n\r\n      const neighbors = getNeighbors(newGrid, current)\r\n\r\n      for (const neighbor of neighbors) {\r\n        if (\r\n          neighbor.type === CELL_TYPE.WALL ||\r\n          closedSet.has(`${neighbor.row},${neighbor.col}`)\r\n        ) {\r\n          continue\r\n        }\r\n\r\n        const tentativeG = current.g + 1\r\n\r\n        if (tentativeG < neighbor.g) {\r\n          neighbor.parent = current\r\n          neighbor.g = tentativeG\r\n          neighbor.h = heuristic(neighbor, endNode)\r\n          neighbor.f = neighbor.g + neighbor.h\r\n\r\n          if (\r\n            !openSet.find(\r\n              (n) => n.row === neighbor.row && n.col === neighbor.col\r\n            )\r\n          ) {\r\n            openSet.push(neighbor)\r\n            if (neighbor.row !== end.row || neighbor.col !== end.col) {\r\n              newGrid[neighbor.row][neighbor.col].type = CELL_TYPE.OPEN\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      setGrid([...newGrid])\r\n      setStats({ nodesVisited, pathLength: 0 })\r\n      await new Promise((resolve) => setTimeout(resolve, 50 - speed))\r\n    }\r\n\r\n    // No path found\r\n    setIsComplete(true)\r\n    setIsRunning(false)\r\n    alert(\"No path found!\")\r\n  }\r\n\r\n  const handleMouseDown = (row, col) => {\r\n    setIsDrawing(true)\r\n    handleCellClick(row, col)\r\n  }\r\n\r\n  const handleMouseEnter = (row, col) => {\r\n    if (isDrawing) {\r\n      handleCellClick(row, col)\r\n    }\r\n  }\r\n\r\n  const handleMouseUp = () => {\r\n    setIsDrawing(false)\r\n  }\r\n\r\n  const handleCellClick = (row, col) => {\r\n    if (isRunning) return\r\n\r\n    const newGrid = [...grid]\r\n    const cell = newGrid[row][col]\r\n\r\n    if (drawMode === \"wall\") {\r\n      // Don't allow walls on start or end\r\n      if (\r\n        (row === start.row && col === start.col) ||\r\n        (row === end.row && col === end.col)\r\n      ) {\r\n        return\r\n      }\r\n      cell.type =\r\n        cell.type === CELL_TYPE.WALL ? CELL_TYPE.EMPTY : CELL_TYPE.WALL\r\n    } else if (drawMode === \"start\") {\r\n      // Clear old start\r\n      if (grid[start.row][start.col].type !== CELL_TYPE.WALL) {\r\n        newGrid[start.row][start.col].type = CELL_TYPE.EMPTY\r\n      }\r\n      setStart({ row, col })\r\n      cell.type = CELL_TYPE.EMPTY\r\n    } else if (drawMode === \"end\") {\r\n      // Clear old end\r\n      if (grid[end.row][end.col].type !== CELL_TYPE.WALL) {\r\n        newGrid[end.row][end.col].type = CELL_TYPE.EMPTY\r\n      }\r\n      setEnd({ row, col })\r\n      cell.type = CELL_TYPE.EMPTY\r\n    }\r\n\r\n    setGrid(newGrid)\r\n  }\r\n\r\n  const generateMaze = () => {\r\n    if (isRunning) return\r\n    const newGrid = [...grid]\r\n\r\n    // Random maze generation\r\n    for (let row = 0; row < GRID_ROWS; row++) {\r\n      for (let col = 0; col < GRID_COLS; col++) {\r\n        if (\r\n          (row === start.row && col === start.col) ||\r\n          (row === end.row && col === end.col)\r\n        ) {\r\n          continue\r\n        }\r\n        newGrid[row][col].type =\r\n          Math.random() < 0.3 ? CELL_TYPE.WALL : CELL_TYPE.EMPTY\r\n      }\r\n    }\r\n    setGrid(newGrid)\r\n  }\r\n\r\n  const stopAlgorithm = () => {\r\n    stopRef.current = true\r\n  }\r\n\r\n  const getCellClass = (cell) => {\r\n    if (cell.row === start.row && cell.col === start.col) return styles.start\r\n    if (cell.row === end.row && cell.col === end.col) return styles.end\r\n\r\n    switch (cell.type) {\r\n      case CELL_TYPE.WALL:\r\n        return styles.wall\r\n      case CELL_TYPE.OPEN:\r\n        return styles.open\r\n      case CELL_TYPE.CLOSED:\r\n        return styles.closed\r\n      case CELL_TYPE.PATH:\r\n        return styles.path\r\n      default:\r\n        return styles.empty\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div className={styles.container}>\r\n      <h1 className={styles.title}>A* Pathfinding Algorithm ðŸŽ¯</h1>\r\n\r\n      {/* Legend */}\r\n      <div className={styles.legend}>\r\n        <div className={styles.legendItem}>\r\n          <div className={`${styles.legendBox} ${styles.start}`} />\r\n          <span>Start</span>\r\n        </div>\r\n        <div className={styles.legendItem}>\r\n          <div className={`${styles.legendBox} ${styles.end}`} />\r\n          <span>End</span>\r\n        </div>\r\n        <div className={styles.legendItem}>\r\n          <div className={`${styles.legendBox} ${styles.wall}`} />\r\n          <span>Wall</span>\r\n        </div>\r\n        <div className={styles.legendItem}>\r\n          <div className={`${styles.legendBox} ${styles.open}`} />\r\n          <span>Open Set</span>\r\n        </div>\r\n        <div className={styles.legendItem}>\r\n          <div className={`${styles.legendBox} ${styles.closed}`} />\r\n          <span>Closed Set</span>\r\n        </div>\r\n        <div className={styles.legendItem}>\r\n          <div className={`${styles.legendBox} ${styles.path}`} />\r\n          <span>Path</span>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Controls */}\r\n      <div className={styles.controls}>\r\n        <div className={styles.controlGroup}>\r\n          <label>Draw Mode:</label>\r\n          <select\r\n            value={drawMode}\r\n            onChange={(e) => setDrawMode(e.target.value)}\r\n            disabled={isRunning}\r\n          >\r\n            <option value=\"wall\">Wall</option>\r\n            <option value=\"start\">Start Point</option>\r\n            <option value=\"end\">End Point</option>\r\n          </select>\r\n        </div>\r\n\r\n        <div className={styles.controlGroup}>\r\n          <label>Speed:</label>\r\n          <input\r\n            type=\"range\"\r\n            min=\"0\"\r\n            max=\"45\"\r\n            value={speed}\r\n            onChange={(e) => setSpeed(Number(e.target.value))}\r\n            className={styles.slider}\r\n          />\r\n        </div>\r\n\r\n        <button\r\n          onClick={runAStar}\r\n          disabled={isRunning}\r\n          className={styles.btnPrimary}\r\n        >\r\n          {isRunning ? \"Running...\" : \"Run A*\"}\r\n        </button>\r\n\r\n        <button\r\n          onClick={stopAlgorithm}\r\n          disabled={!isRunning}\r\n          className={styles.btnSecondary}\r\n        >\r\n          Stop\r\n        </button>\r\n\r\n        <button\r\n          onClick={generateMaze}\r\n          disabled={isRunning}\r\n          className={styles.btnSecondary}\r\n        >\r\n          Generate Maze\r\n        </button>\r\n\r\n        <button\r\n          onClick={initializeGrid}\r\n          disabled={isRunning}\r\n          className={styles.btnSecondary}\r\n        >\r\n          Clear Grid\r\n        </button>\r\n      </div>\r\n\r\n      {/* Stats */}\r\n      <div className={styles.stats}>\r\n        <div className={styles.stat}>\r\n          <span className={styles.statLabel}>Nodes Visited:</span>\r\n          <span className={styles.statValue}>{stats.nodesVisited}</span>\r\n        </div>\r\n        {isComplete && stats.pathLength > 0 && (\r\n          <div className={styles.stat}>\r\n            <span className={styles.statLabel}>Path Length:</span>\r\n            <span className={styles.statValue}>{stats.pathLength}</span>\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Grid */}\r\n      <div className={styles.gridContainer} onMouseLeave={handleMouseUp}>\r\n        <div className={styles.grid}>\r\n          {grid.map((row, rowIdx) => (\r\n            <div key={rowIdx} className={styles.row}>\r\n              {row.map((cell, colIdx) => (\r\n                <div\r\n                  key={`${rowIdx}-${colIdx}`}\r\n                  className={`${styles.cell} ${getCellClass(cell)}`}\r\n                  onMouseDown={() => handleMouseDown(rowIdx, colIdx)}\r\n                  onMouseEnter={() => handleMouseEnter(rowIdx, colIdx)}\r\n                  onMouseUp={handleMouseUp}\r\n                />\r\n              ))}\r\n            </div>\r\n          ))}\r\n        </div>\r\n      </div>\r\n\r\n      {/* Instructions */}\r\n      <div className={styles.instructions}>\r\n        <h3>How to use:</h3>\r\n        <ul>\r\n          <li>Select &quot;Wall&quot; mode and click/drag to draw walls</li>\r\n          <li>\r\n            Select &quot;Start Point&quot; or &quot;End Point&quot; mode to\r\n            reposition them\r\n          </li>\r\n          <li>Click &quot;Generate Maze&quot; for a random maze</li>\r\n          <li>\r\n            Click &quot;Run A*&quot; to watch the algorithm find the shortest\r\n            path\r\n          </li>\r\n          <li>\r\n            A* uses f(n) = g(n) + h(n) where g is cost from start, h is\r\n            heuristic to goal\r\n          </li>\r\n        </ul>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default AStarPathfinding\r\n"],"names":["CELL_TYPE","AStarPathfinding","grid","setGrid","useState","start","setStart","row","col","end","setEnd","isDrawing","setIsDrawing","isRunning","setIsRunning","isComplete","setIsComplete","speed","setSpeed","stats","setStats","nodesVisited","pathLength","drawMode","setDrawMode","stopRef","useRef","useEffect","initializeGrid","newGrid","currentRow","push","type","f","Infinity","g","h","parent","heuristic","node","Math","abs","getNeighbors","neighbors","r","c","forEach","_ref","newRow","newCol","reconstructPath","endNode","path","current","unshift","handleMouseUp","handleCellClick","cell","getCellClass","styles","_jsxs","className","children","_jsx","value","onChange","e","target","disabled","min","max","Number","onClick","async","map","startNode","openSet","closedSet","Set","length","sort","a","b","shift","Promise","resolve","setTimeout","add","neighbor","has","tentativeG","find","n","alert","stopAlgorithm","generateMaze","random","onMouseLeave","rowIdx","colIdx","onMouseDown","handleMouseDown","onMouseEnter","handleMouseEnter","onMouseUp"],"sourceRoot":""}