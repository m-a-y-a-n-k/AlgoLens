{"version":3,"file":"static/js/8346.7552c6af.chunk.js","mappings":"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","sources":["routing/site/os/components/DiningPhilosophers/index.jsx","../node_modules/framer-motion/src/utils/use-composed-ref.ts","../node_modules/framer-motion/src/components/AnimatePresence/PopChild.tsx","../node_modules/framer-motion/src/components/AnimatePresence/PresenceChild.tsx","../node_modules/framer-motion/src/components/AnimatePresence/utils.ts","../node_modules/framer-motion/src/components/AnimatePresence/index.tsx"],"sourcesContent":["import React, { useState } from \"react\"\nimport { motion, AnimatePresence } from \"framer-motion\"\nimport \"./DiningPhilosophers.css\"\n\nconst DiningPhilosophers = () => {\n  const [philosophers, setPhilosophers] = useState([\n    { id: 0, status: \"thinking\", leftChopstick: 0, rightChopstick: 1 },\n    { id: 1, status: \"thinking\", leftChopstick: 1, rightChopstick: 2 },\n    { id: 2, status: \"thinking\", leftChopstick: 2, rightChopstick: 3 },\n    { id: 3, status: \"thinking\", leftChopstick: 3, rightChopstick: 4 },\n    { id: 4, status: \"thinking\", leftChopstick: 4, rightChopstick: 0 },\n  ])\n\n  const [chopsticks, setChopsticks] = useState([true, true, true, true, true]) // true means available\n  const [logs, setLogs] = useState([\n    \"Simulation started. All philosophers are thinking.\",\n  ])\n\n  const addLog = (msg) => {\n    setLogs((prev) => [msg, ...prev].slice(0, 5))\n  }\n\n  const togglePhilosopher = (id) => {\n    const phil = philosophers[id]\n    if (phil.status === \"thinking\") {\n      // Try to eat\n      if (chopsticks[phil.leftChopstick] && chopsticks[phil.rightChopstick]) {\n        // Can eat\n        const nextChopsticks = [...chopsticks]\n        nextChopsticks[phil.leftChopstick] = false\n        nextChopsticks[phil.rightChopstick] = false\n        setChopsticks(nextChopsticks)\n\n        const nextPhils = [...philosophers]\n        nextPhils[id].status = \"eating\"\n        setPhilosophers(nextPhils)\n        addLog(`Philosopher ${id} is now eating.`)\n      } else {\n        addLog(`Philosopher ${id} is waiting for chopsticks.`)\n        const nextPhils = [...philosophers]\n        nextPhils[id].status = \"hungry\"\n        setPhilosophers(nextPhils)\n      }\n    } else if (phil.status === \"eating\" || phil.status === \"hungry\") {\n      // stop eating or stop being hungry\n      if (phil.status === \"eating\") {\n        const nextChopsticks = [...chopsticks]\n        nextChopsticks[phil.leftChopstick] = true\n        nextChopsticks[phil.rightChopstick] = true\n        setChopsticks(nextChopsticks)\n        addLog(`Philosopher ${id} finished eating and is now thinking.`)\n      }\n      const nextPhils = [...philosophers]\n      nextPhils[id].status = \"thinking\"\n      setPhilosophers(nextPhils)\n    }\n  }\n\n  return (\n    <div className=\"os-visualizer container py-4\">\n      <div className=\"text-center mb-5\">\n        <h2 className=\"display-6 fw-bold text-primary\">Dining Philosophers</h2>\n        <p className=\"text-muted\">\n          A classic synchronization problem illustrating resource contention and\n          deadlock.\n        </p>\n      </div>\n\n      <div className=\"row justify-content-center align-items-center\">\n        <div className=\"col-lg-7 text-center\">\n          <div className=\"table-wrapper\">\n            <div className=\"table-circle shadow\">\n              <span className=\"table-label\">Shared Resources</span>\n              {/* Chopsticks */}\n              {chopsticks.map((available, i) => {\n                const angle = (i * 72 + 36) * (Math.PI / 180)\n                const x = 50 + 35 * Math.cos(angle)\n                const y = 50 + 35 * Math.sin(angle)\n                return (\n                  <motion.div\n                    key={`chopstick-${i}`}\n                    className={`chopstick ${available ? \"available\" : \"taken\"}`}\n                    style={{\n                      left: `${x}%`,\n                      top: `${y}%`,\n                      transform: `translate(-50%, -50%) rotate(${\n                        i * 72 + 126\n                      }deg)`,\n                    }}\n                    animate={{\n                      scale: available ? 1 : 0.8,\n                      opacity: available ? 1 : 0.3,\n                    }}\n                  />\n                )\n              })}\n            </div>\n\n            {/* Philosophers */}\n            {philosophers.map((phil, i) => {\n              const angle = (i * 72 - 90) * (Math.PI / 180)\n              const x = 50 + 45 * Math.cos(angle)\n              const y = 50 + 45 * Math.sin(angle)\n              return (\n                <motion.div\n                  key={`phil-${i}`}\n                  className={`philosopher-node shadow-sm ${phil.status}`}\n                  style={{ left: `${x}%`, top: `${y}%` }}\n                  whileHover={{ scale: 1.1 }}\n                  onClick={() => togglePhilosopher(i)}\n                >\n                  <div className=\"phil-avatar\">\n                    {phil.status === \"eating\"\n                      ? \"üçú\"\n                      : phil.status === \"hungry\"\n                      ? \"ü§§\"\n                      : \"ü§î\"}\n                  </div>\n                  <div className=\"phil-id\">P{phil.id}</div>\n                </motion.div>\n              )\n            })}\n          </div>\n        </div>\n\n        <div className=\"col-lg-5\">\n          <div className=\"card border-0 shadow-sm p-4 h-100\">\n            <h5 className=\"fw-bold mb-3\">Philosopher Status</h5>\n            <div className=\"status-legend mb-3\">\n              <div className=\"d-flex align-items-center mb-2\">\n                <span className=\"legend-dot thinking\"></span>\n                <span className=\"ms-2 small\">Thinking (Idle)</span>\n              </div>\n              <div className=\"d-flex align-items-center mb-2\">\n                <span className=\"legend-dot hungry\"></span>\n                <span className=\"ms-2 small\">\n                  Hungry (Waiting for keys/forks)\n                </span>\n              </div>\n              <div className=\"d-flex align-items-center mb-2\">\n                <span className=\"legend-dot eating\"></span>\n                <span className=\"ms-2 small\">Eating (Holding resources)</span>\n              </div>\n            </div>\n\n            <div className=\"instructions alert alert-info py-2\">\n              <small>\n                Click on a philosopher to toggle their state. Two adjacent\n                philosophers cannot eat simultaneously.\n              </small>\n            </div>\n\n            <h6 className=\"fw-bold mt-4\">Simulation Logs</h6>\n            <div className=\"log-container\">\n              <AnimatePresence>\n                {logs.map((log, i) => (\n                  <motion.div\n                    key={log + i}\n                    initial={{ opacity: 0, x: -10 }}\n                    animate={{ opacity: 1, x: 0 }}\n                    exit={{ opacity: 0 }}\n                    className=\"log-entry\"\n                  >\n                    {log}\n                  </motion.div>\n                ))}\n              </AnimatePresence>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default DiningPhilosophers\n","/**\n * Taken from https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\nimport * as React from \"react\"\n\ntype PossibleRef<T> = React.Ref<T> | undefined\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T): void | (() => void) {\n    if (typeof ref === \"function\") {\n        return ref(value)\n    } else if (ref !== null && ref !== undefined) {\n        ;(ref as React.MutableRefObject<T>).current = value\n    }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n    return (node) => {\n        let hasCleanup = false\n        const cleanups = refs.map((ref) => {\n            const cleanup = setRef(ref, node)\n            if (!hasCleanup && typeof cleanup === \"function\") {\n                hasCleanup = true\n            }\n            return cleanup\n        })\n        // React <19 will log an error to the console if a callback ref returns a\n        // value. We don't use ref cleanups internally so this will only happen if a\n        // user's ref callback returns a value, which we only expect if they are\n        // using the cleanup functionality added in React 19.\n        if (hasCleanup) {\n            return () => {\n                for (let i = 0; i < cleanups.length; i++) {\n                    const cleanup = cleanups[i]\n                    if (typeof cleanup === \"function\") {\n                        cleanup()\n                    } else {\n                        setRef(refs[i], null)\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    return React.useCallback(composeRefs(...refs), refs)\n}\n\nexport { useComposedRefs }\n","\"use client\"\n\nimport { isHTMLElement } from \"motion-dom\"\nimport * as React from \"react\"\nimport { useContext, useId, useInsertionEffect, useRef } from \"react\"\n\nimport { MotionConfigContext } from \"../../context/MotionConfigContext\"\nimport { useComposedRefs } from \"../../utils/use-composed-ref\"\n\ninterface Size {\n    width: number\n    height: number\n    top: number\n    left: number\n    right: number\n}\n\ninterface Props {\n    children: React.ReactElement\n    isPresent: boolean\n    anchorX?: \"left\" | \"right\"\n    root?: HTMLElement | ShadowRoot\n}\n\ninterface MeasureProps extends Props {\n    childRef: React.RefObject<HTMLElement | null>\n    sizeRef: React.RefObject<Size>\n}\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component<MeasureProps> {\n    getSnapshotBeforeUpdate(prevProps: MeasureProps) {\n        const element = this.props.childRef.current\n        if (element && prevProps.isPresent && !this.props.isPresent) {\n            const parent = element.offsetParent\n            const parentWidth = isHTMLElement(parent)\n                ? parent.offsetWidth || 0\n                : 0\n\n            const size = this.props.sizeRef.current!\n            size.height = element.offsetHeight || 0\n            size.width = element.offsetWidth || 0\n            size.top = element.offsetTop\n            size.left = element.offsetLeft\n            size.right = parentWidth - size.width - size.left\n        }\n\n        return null\n    }\n\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */\n    componentDidUpdate() {}\n\n    render() {\n        return this.props.children\n    }\n}\n\nexport function PopChild({ children, isPresent, anchorX, root }: Props) {\n    const id = useId()\n    const ref = useRef<HTMLElement>(null)\n    const size = useRef<Size>({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        right: 0,\n    })\n    const { nonce } = useContext(MotionConfigContext)\n    /**\n     * In React 19, refs are passed via props.ref instead of element.ref.\n     * We check props.ref first (React 19) and fall back to element.ref (React 18).\n     */\n    const childRef =\n        (children.props as { ref?: React.Ref<HTMLElement> })?.ref ??\n        (children as unknown as { ref?: React.Ref<HTMLElement> })?.ref\n    const composedRef = useComposedRefs(ref, childRef)\n\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can't apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */\n    useInsertionEffect(() => {\n        const { width, height, top, left, right } = size.current\n        if (isPresent || !ref.current || !width || !height) return\n\n        const x = anchorX === \"left\" ? `left: ${left}` : `right: ${right}`\n\n        ref.current.dataset.motionPopId = id\n\n        const style = document.createElement(\"style\")\n        if (nonce) style.nonce = nonce\n\n        const parent = root ?? document.head\n        parent.appendChild(style)\n\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            top: ${top}px !important;\n          }\n        `)\n        }\n\n        return () => {\n            if (parent.contains(style)) {\n                parent.removeChild(style)\n            }\n        }\n    }, [isPresent])\n\n    return (\n        <PopChildMeasure isPresent={isPresent} childRef={ref} sizeRef={size}>\n            {React.cloneElement(children as any, { ref: composedRef })}\n        </PopChildMeasure>\n    )\n}\n","\"use client\"\n\nimport * as React from \"react\"\nimport { useId, useMemo } from \"react\"\nimport {\n    PresenceContext,\n    type PresenceContextProps,\n} from \"../../context/PresenceContext\"\nimport { VariantLabels } from \"../../motion/types\"\nimport { useConstant } from \"../../utils/use-constant\"\nimport { PopChild } from \"./PopChild\"\n\ninterface PresenceChildProps {\n    children: React.ReactElement\n    isPresent: boolean\n    onExitComplete?: () => void\n    initial?: false | VariantLabels\n    custom?: any\n    presenceAffectsLayout: boolean\n    mode: \"sync\" | \"popLayout\" | \"wait\"\n    anchorX?: \"left\" | \"right\"\n    root?: HTMLElement | ShadowRoot\n}\n\nexport const PresenceChild = ({\n    children,\n    initial,\n    isPresent,\n    onExitComplete,\n    custom,\n    presenceAffectsLayout,\n    mode,\n    anchorX,\n    root\n}: PresenceChildProps) => {\n    const presenceChildren = useConstant(newChildrenMap)\n    const id = useId()\n\n    let isReusedContext = true\n    let context = useMemo((): PresenceContextProps => {\n        isReusedContext = false\n        return {\n            id,\n            initial,\n            isPresent,\n            custom,\n            onExitComplete: (childId: string) => {\n                presenceChildren.set(childId, true)\n\n                for (const isComplete of presenceChildren.values()) {\n                    if (!isComplete) return // can stop searching when any is incomplete\n                }\n\n                onExitComplete && onExitComplete()\n            },\n            register: (childId: string) => {\n                presenceChildren.set(childId, false)\n                return () => presenceChildren.delete(childId)\n            },\n        }\n    }, [isPresent, presenceChildren, onExitComplete])\n\n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    if (presenceAffectsLayout && isReusedContext) {\n        context = { ...context }\n    }\n\n    useMemo(() => {\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false))\n    }, [isPresent])\n\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(() => {\n        !isPresent &&\n            !presenceChildren.size &&\n            onExitComplete &&\n            onExitComplete()\n    }, [isPresent])\n\n    if (mode === \"popLayout\") {\n        children = (\n            <PopChild isPresent={isPresent} anchorX={anchorX} root={root}>\n                {children}\n            </PopChild>\n        )\n    }\n\n    return (\n        <PresenceContext.Provider value={context}>\n            {children}\n        </PresenceContext.Provider>\n    )\n}\n\nfunction newChildrenMap(): Map<string, boolean> {\n    return new Map()\n}\n","import { isValidElement, Children, ReactElement, ReactNode } from \"react\"\n\nexport type ComponentKey = string | number\n\nexport const getChildKey = (child: ReactElement<any>): ComponentKey =>\n    child.key || \"\"\n\nexport function onlyElements(children: ReactNode): ReactElement<any>[] {\n    const filtered: ReactElement<any>[] = []\n\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, (child) => {\n        if (isValidElement(child)) filtered.push(child)\n    })\n\n    return filtered\n}\n","\"use client\"\n\nimport * as React from \"react\"\nimport { useContext, useMemo, useRef, useState } from \"react\"\nimport { LayoutGroupContext } from \"../../context/LayoutGroupContext\"\nimport { useConstant } from \"../../utils/use-constant\"\nimport { useIsomorphicLayoutEffect } from \"../../utils/use-isomorphic-effect\"\nimport { PresenceChild } from \"./PresenceChild\"\nimport { AnimatePresenceProps } from \"./types\"\nimport { usePresence } from \"./use-presence\"\nimport { ComponentKey, getChildKey, onlyElements } from \"./utils\"\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nexport const AnimatePresence = ({\n    children,\n    custom,\n    initial = true,\n    onExitComplete,\n    presenceAffectsLayout = true,\n    mode = \"sync\",\n    propagate = false,\n    anchorX = \"left\",\n    root\n}: React.PropsWithChildren<AnimatePresenceProps>) => {\n    const [isParentPresent, safeToRemove] = usePresence(propagate)\n\n    /**\n     * Filter any children that aren't ReactElements. We can only track components\n     * between renders with a props.key.\n     */\n    const presentChildren = useMemo(() => onlyElements(children), [children])\n\n    /**\n     * Track the keys of the currently rendered children. This is used to\n     * determine which children are exiting.\n     */\n    const presentKeys =\n        propagate && !isParentPresent ? [] : presentChildren.map(getChildKey)\n\n    /**\n     * If `initial={false}` we only want to pass this to components in the first render.\n     */\n    const isInitialRender = useRef(true)\n\n    /**\n     * A ref containing the currently present children. When all exit animations\n     * are complete, we use this to re-render the component with the latest children\n     * *committed* rather than the latest children *rendered*.\n     */\n    const pendingPresentChildren = useRef(presentChildren)\n\n    /**\n     * Track which exiting children have finished animating out.\n     */\n    const exitComplete = useConstant(() => new Map<ComponentKey, boolean>())\n\n    /**\n     * Track which components are currently processing exit to prevent duplicate processing.\n     */\n    const exitingComponents = useRef(new Set<ComponentKey>())\n\n    /**\n     * Save children to render as React state. To ensure this component is concurrent-safe,\n     * we check for exiting children via an effect.\n     */\n    const [diffedChildren, setDiffedChildren] = useState(presentChildren)\n    const [renderedChildren, setRenderedChildren] = useState(presentChildren)\n\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false\n        pendingPresentChildren.current = presentChildren\n\n        /**\n         * Update complete status of exiting children.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const key = getChildKey(renderedChildren[i])\n\n            if (!presentKeys.includes(key)) {\n                if (exitComplete.get(key) !== true) {\n                    exitComplete.set(key, false)\n                }\n            } else {\n                exitComplete.delete(key)\n                exitingComponents.current.delete(key)\n            }\n        }\n    }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")])\n\n    const exitingChildren: any[] = []\n\n    if (presentChildren !== diffedChildren) {\n        let nextChildren = [...presentChildren]\n\n        /**\n         * Loop through all the currently rendered components and decide which\n         * are exiting.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const child = renderedChildren[i]\n            const key = getChildKey(child)\n\n            if (!presentKeys.includes(key)) {\n                nextChildren.splice(i, 0, child)\n                exitingChildren.push(child)\n            }\n        }\n\n        /**\n         * If we're in \"wait\" mode, and we have exiting children, we want to\n         * only render these until they've all exited.\n         */\n        if (mode === \"wait\" && exitingChildren.length) {\n            nextChildren = exitingChildren\n        }\n\n        setRenderedChildren(onlyElements(nextChildren))\n        setDiffedChildren(presentChildren)\n\n        /**\n         * Early return to ensure once we've set state with the latest diffed\n         * children, we can immediately re-render.\n         */\n        return null\n    }\n\n    if (\n        process.env.NODE_ENV !== \"production\" &&\n        mode === \"wait\" &&\n        renderedChildren.length > 1\n    ) {\n        console.warn(\n            `You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`\n        )\n    }\n\n    /**\n     * If we've been provided a forceRender function by the LayoutGroupContext,\n     * we can use it to force a re-render amongst all surrounding components once\n     * all components have finished animating out.\n     */\n    const { forceRender } = useContext(LayoutGroupContext)\n\n    return (\n        <>\n            {renderedChildren.map((child) => {\n                const key = getChildKey(child)\n\n                const isPresent =\n                    propagate && !isParentPresent\n                        ? false\n                        : presentChildren === renderedChildren ||\n                          presentKeys.includes(key)\n\n                const onExit = () => {\n                    if (exitingComponents.current.has(key)) {\n                        return\n                    }\n                    exitingComponents.current.add(key)\n\n                    if (exitComplete.has(key)) {\n                        exitComplete.set(key, true)\n                    } else {\n                        return\n                    }\n\n                    let isEveryExitComplete = true\n                    exitComplete.forEach((isExitComplete) => {\n                        if (!isExitComplete) isEveryExitComplete = false\n                    })\n\n                    if (isEveryExitComplete) {\n                        forceRender?.()\n                        setRenderedChildren(pendingPresentChildren.current)\n\n                        propagate && safeToRemove?.()\n\n                        onExitComplete && onExitComplete()\n                    }\n                }\n\n                return (\n                    <PresenceChild\n                        key={key}\n                        isPresent={isPresent}\n                        initial={\n                            !isInitialRender.current || initial\n                                ? undefined\n                                : false\n                        }\n                        custom={custom}\n                        presenceAffectsLayout={presenceAffectsLayout}\n                        mode={mode}\n                        root={root}\n                        onExitComplete={isPresent ? undefined : onExit}\n                        anchorX={anchorX}\n                    >\n                        {child}\n                    </PresenceChild>\n                )\n            })}\n        </>\n    )\n}\n"],"names":["DiningPhilosophers","philosophers","setPhilosophers","useState","id","status","leftChopstick","rightChopstick","chopsticks","setChopsticks","logs","setLogs","addLog","msg","prev","slice","_jsxs","className","children","_jsx","map","available","i","angle","Math","PI","x","cos","y","sin","motion","style","left","top","transform","animate","scale","opacity","phil","whileHover","onClick","nextChopsticks","nextPhils","togglePhilosopher","AnimatePresence","log","initial","exit","setRef","ref","value","undefined","current","composeRefs","_len","arguments","length","refs","Array","_key","node","hasCleanup","cleanups","cleanup","PopChildMeasure","React","getSnapshotBeforeUpdate","prevProps","element","isPresent","props","parent","offsetParent","parentWidth","isHTMLElement","offsetWidth","size","offsetTop","offsetLeft","right","width","componentDidUpdate","this","PopChild","_ref","anchorX","root","useId","useRef","height","childRef","_len2","_key2","nonce","document","head","appendChild","sheet","insertRule","contains","removeChild","jsx","sizeRef","composedRef","PresenceChild","onExitComplete","custom","presenceAffectsLayout","mode","presenceChildren","useConstant","newChildrenMap","context","useMemo","childId","set","isComplete","register","isReusedContext","forEach","_","key","PresenceContext","getChildKey","child","onlyElements","filtered","Children","isValidElement","push","propagate","presentChildren","presentKeys","isParentPresent","isInitialRender","pendingPresentChildren","renderedChildren","exitComplete","delete","exitingComponents","join","diffedChildren","nextChildren","exitingChildren","setRenderedChildren","includes","add","has","isExitComplete","safeToRemove"],"sourceRoot":""}