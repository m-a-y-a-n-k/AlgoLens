"use strict";(self.webpackChunkAlgoLens=self.webpackChunkAlgoLens||[]).push([[2576],{2576:(n,e,t)=>{t.r(e),t.d(e,{default:()=>M});var s=t(2791);const i="DisjointSetUnion_container__PZcRs",a="DisjointSetUnion_title__HzNKT",o="DisjointSetUnion_description__S5utG",c="DisjointSetUnion_section__PtSm6",r="DisjointSetUnion_initializeGroup__-fDc+",l="DisjointSetUnion_sizeInfo__EeUev",h="DisjointSetUnion_operations__lOOgv",d="DisjointSetUnion_operationCard__ac-Ei",p="DisjointSetUnion_inputGroup__GUEQl",m="DisjointSetUnion_input__u8Fp-",u="DisjointSetUnion_btnPrimary__S910n",j="DisjointSetUnion_btnSecondary__ZfBp2",_="DisjointSetUnion_btnOperation__A8bKC",x="DisjointSetUnion_btnNav__G3rVc",S="DisjointSetUnion_lastOperation__Lbj4S",g="DisjointSetUnion_animationControls__MHtVN",N="DisjointSetUnion_stepCounter__5TxGI",v="DisjointSetUnion_stepMessage__YhVZi",f="DisjointSetUnion_forestContainer__4HnLB",k="DisjointSetUnion_forestSvg__VWRhg",U="DisjointSetUnion_edge__e3e85",y="DisjointSetUnion_highlightedEdge__Jtglt",D="DisjointSetUnion_node__E2cfk",b="DisjointSetUnion_rootNode__BbqUg",C="DisjointSetUnion_highlightedNode__uv6KB",w="DisjointSetUnion_nodeText__3rp5h",z="DisjointSetUnion_infoText__R0W6K",A="DisjointSetUnion_rootLabel__13gbj",P="DisjointSetUnion_componentsGrid__SsJ+L",I="DisjointSetUnion_componentCard__LO5oz",O="DisjointSetUnion_componentHeader__OrwGY",E="DisjointSetUnion_rootValue__PrIlP",F="DisjointSetUnion_componentBody__u5JbN",G="DisjointSetUnion_componentFooter__-IzYq",L="DisjointSetUnion_complexityGrid__GgcVg",R="DisjointSetUnion_complexityCard__D8xyR",T="DisjointSetUnion_complexity__SXJIx",H="DisjointSetUnion_complexityNote__AP0bo",K="DisjointSetUnion_explanation__AmteS",V="DisjointSetUnion_note__Dj33H";var W=t(184);class B{constructor(n){this.parent=Array.from({length:n},((n,e)=>e)),this.rank=Array(n).fill(0),this.size=Array(n).fill(1),this.n=n,this.animationSteps=[]}find(n){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];e&&this.animationSteps.push({type:"find-start",node:n,message:"Finding root of element ".concat(n)});const t=[];let s=n;for(;this.parent[s]!==s;)t.push(s),e&&this.animationSteps.push({type:"find-traverse",node:s,parent:this.parent[s],message:"".concat(s," \u2192 parent is ").concat(this.parent[s])}),s=this.parent[s];e&&this.animationSteps.push({type:"find-root",node:s,message:"Root found: ".concat(s)});for(const i of t)e&&this.parent[i]!==s&&this.animationSteps.push({type:"path-compression",node:i,oldParent:this.parent[i],newParent:s,message:"Path compression: ".concat(i," now points directly to ").concat(s)}),this.parent[i]=s;return s}union(n,e){this.animationSteps=[],this.animationSteps.push({type:"union-start",nodes:[n,e],message:"Union operation: merging sets containing ".concat(n," and ").concat(e)});const t=this.find(n),s=this.find(e);return t===s?(this.animationSteps.push({type:"already-connected",nodes:[n,e],root:t,message:"".concat(n," and ").concat(e," are already in the same set (root: ").concat(t,")")}),!1):(this.rank[t]<this.rank[s]?(this.parent[t]=s,this.size[s]+=this.size[t],this.animationSteps.push({type:"union-complete",child:t,parent:s,message:"Attached tree ".concat(t," (rank ").concat(this.rank[t],") under ").concat(s," (rank ").concat(this.rank[s],")")})):this.rank[t]>this.rank[s]?(this.parent[s]=t,this.size[t]+=this.size[s],this.animationSteps.push({type:"union-complete",child:s,parent:t,message:"Attached tree ".concat(s," (rank ").concat(this.rank[s],") under ").concat(t," (rank ").concat(this.rank[t],")")})):(this.parent[s]=t,this.rank[t]++,this.size[t]+=this.size[s],this.animationSteps.push({type:"union-complete",child:s,parent:t,message:"Same rank: attached ".concat(s," under ").concat(t,", increased rank to ").concat(this.rank[t])})),!0)}connected(n,e){return this.find(n,!1)===this.find(e,!1)}getComponents(){const n={};for(let e=0;e<this.n;e++){const t=this.find(e,!1);n[t]||(n[t]=[]),n[t].push(e)}return n}clone(){const n=new B(this.n);return n.parent=[...this.parent],n.rank=[...this.rank],n.size=[...this.size],n}}const M=()=>{const[n,e]=(0,s.useState)(new B(10)),[t,M]=(0,s.useState)(10),[J,q]=(0,s.useState)(""),[Y,Z]=(0,s.useState)(""),[Q,X]=(0,s.useState)(""),[$,nn]=(0,s.useState)([]),[en,tn]=(0,s.useState)(-1),[sn,an]=(0,s.useState)([]),[on,cn]=(0,s.useState)([]),[rn,ln]=(0,s.useState)(""),hn=n=>{if(!n)return;const e=[],t=[];switch(n.type){case"find-start":case"find-root":e.push(n.node);break;case"find-traverse":e.push(n.node,n.parent),t.push([n.node,n.parent]);break;case"path-compression":e.push(n.node,n.newParent),t.push([n.node,n.newParent]);break;case"union-start":e.push(...n.nodes);break;case"union-complete":e.push(n.child,n.parent),t.push([n.child,n.parent]);break;case"already-connected":e.push(...n.nodes,n.root)}an(e),cn(t)},dn=n.getComponents(),pn=Object.keys(dn).length,mn=(e,t,s,i,a,o)=>{const c=[],r=t.filter((t=>n.parent[t]===e&&t!==e)),l=sn.includes(e),h=n.parent[e]===e;return r.forEach(((n,l)=>{const h=o/Math.pow(2,a+1),d=s+(l-r.length/2)*h*2,p=i+80,m=on.some((t=>{let[s,i]=t;return s===e&&i===n||s===n&&i===e}));c.push((0,W.jsx)("line",{x1:s,y1:i+25,x2:d,y2:p-25,className:"".concat(U," ").concat(m?y:""),strokeWidth:"3"},"edge-".concat(e,"-").concat(n))),c.push(...mn(n,t,d,p,a+1,o))})),c.push((0,W.jsxs)("g",{children:[(0,W.jsx)("circle",{cx:s,cy:i,r:25,className:"".concat(D," ").concat(h?b:""," ").concat(l?C:"")}),(0,W.jsxs)("text",{x:s,y:i-35,textAnchor:"middle",className:z,children:["rank: ",n.rank[e]]}),(0,W.jsx)("text",{x:s,y:i+6,textAnchor:"middle",className:w,children:e}),h&&(0,W.jsx)("text",{x:s,y:i+42,textAnchor:"middle",className:A,children:"Root"})]},"node-".concat(e))),c},un=en>=0&&en<$.length?$[en]:null;return(0,W.jsxs)("div",{className:i,children:[(0,W.jsx)("h1",{className:a,children:"Disjoint Set Union (Union-Find) \ud83d\udd17"}),(0,W.jsx)("div",{className:o,children:(0,W.jsx)("p",{children:"A data structure that keeps track of elements partitioned into disjoint (non-overlapping) sets. Supports efficient union and find operations with path compression and union by rank optimizations."})}),(0,W.jsxs)("div",{className:c,children:[(0,W.jsx)("h3",{children:"Initialize DSU"}),(0,W.jsxs)("div",{className:r,children:[(0,W.jsx)("input",{type:"number",value:t,onChange:n=>M(n.target.value),placeholder:"Size",className:m,min:"2",max:"20"}),(0,W.jsx)("button",{onClick:()=>{const n=parseInt(t,10);isNaN(n)||n<2||n>20?alert("Please enter a size between 2 and 20"):(e(new B(n)),nn([]),tn(-1),an([]),cn([]),ln("Initialized DSU with ".concat(n," elements")))},className:u,children:"Initialize"}),(0,W.jsx)("button",{onClick:()=>{const n=new B(8);n.union(0,1),n.union(2,3),n.union(4,5),n.union(6,7),n.union(0,2),n.union(4,6),e(n.clone()),nn([]),tn(-1),an([]),cn([]),ln("Loaded preset example with 4 components")},className:j,children:"Load Example"}),(0,W.jsxs)("span",{className:l,children:["Current size: ",n.n," elements | ",pn," component(s)"]})]})]}),(0,W.jsxs)("div",{className:h,children:[(0,W.jsxs)("div",{className:d,children:[(0,W.jsx)("h4",{children:"Union Operation"}),(0,W.jsxs)("div",{className:p,children:[(0,W.jsx)("input",{type:"number",value:J,onChange:n=>q(n.target.value),placeholder:"Element 1",className:m,min:"0",max:n.n-1}),(0,W.jsx)("input",{type:"number",value:Y,onChange:n=>Z(n.target.value),placeholder:"Element 2",className:m,min:"0",max:n.n-1}),(0,W.jsx)("button",{onClick:()=>{const t=parseInt(J,10),s=parseInt(Y,10);if(isNaN(t)||isNaN(s)||t<0||t>=n.n||s<0||s>=n.n)return void alert("Please enter valid values between 0 and ".concat(n.n-1));const i=n.clone(),a=i.union(t,s);e(i),nn(i.animationSteps),tn(0),q(""),Z(""),a?(ln("Union(".concat(t,", ").concat(s,") - Sets merged")),hn(i.animationSteps[0])):ln("Union(".concat(t,", ").concat(s,") - Already connected"))},className:_,children:"Union"})]})]}),(0,W.jsxs)("div",{className:d,children:[(0,W.jsx)("h4",{children:"Find Operation"}),(0,W.jsxs)("div",{className:p,children:[(0,W.jsx)("input",{type:"number",value:Q,onChange:n=>X(n.target.value),placeholder:"Element",className:m,min:"0",max:n.n-1}),(0,W.jsx)("button",{onClick:()=>{const t=parseInt(Q,10);if(isNaN(t)||t<0||t>=n.n)return void alert("Please enter a value between 0 and ".concat(n.n-1));const s=n.clone(),i=s.find(t);e(s),nn(s.animationSteps),tn(0),X(""),ln("Find(".concat(t,") = ").concat(i)),hn(s.animationSteps[0])},className:_,children:"Find"})]})]})]}),rn&&(0,W.jsx)("div",{className:S,children:rn}),$.length>0&&(0,W.jsxs)("div",{className:g,children:[(0,W.jsx)("button",{onClick:()=>{if(en>0){const n=en-1;tn(n),hn($[n])}},disabled:en<=0,className:x,children:"\u2190 Previous"}),(0,W.jsxs)("span",{className:N,children:["Step ",en+1," of ",$.length]}),(0,W.jsx)("button",{onClick:()=>{if(en<$.length-1){const n=en+1;tn(n),hn($[n])}},disabled:en>=$.length-1,className:x,children:"Next \u2192"}),(0,W.jsx)("button",{onClick:()=>{an([]),cn([])},className:x,children:"Clear Highlight"})]}),un&&(0,W.jsxs)("div",{className:v,children:[(0,W.jsxs)("strong",{children:["Step ",en+1,":"]})," ",un.message]}),(0,W.jsxs)("div",{className:c,children:[(0,W.jsxs)("h3",{children:["Forest Structure (",pn," Component(s))"]}),(0,W.jsx)("div",{className:f,children:(0,W.jsx)("svg",{width:"900",height:"400",className:k,children:(()=>{const n=Object.entries(dn),e=900/n.length,t=[];return n.forEach(((n,s)=>{let[i,a]=n;const o=(s+.5)*e,c=mn(parseInt(i),a,o,60,0,Math.min(80,e/2));t.push(...c)})),t})()})})]}),(0,W.jsxs)("div",{className:c,children:[(0,W.jsx)("h3",{children:"Components"}),(0,W.jsx)("div",{className:P,children:Object.entries(dn).map((e=>{let[t,s]=e;return(0,W.jsxs)("div",{className:I,children:[(0,W.jsxs)("div",{className:O,children:["Root: ",(0,W.jsx)("span",{className:E,children:t})]}),(0,W.jsxs)("div",{className:F,children:["Elements: ",s.sort(((n,e)=>n-e)).join(", ")]}),(0,W.jsxs)("div",{className:G,children:["Size: ",s.length," | Rank: ",n.rank[parseInt(t)]]})]},t)}))})]}),(0,W.jsxs)("div",{className:c,children:[(0,W.jsx)("h3",{children:"Time Complexity"}),(0,W.jsxs)("div",{className:L,children:[(0,W.jsxs)("div",{className:R,children:[(0,W.jsx)("h4",{children:"Find"}),(0,W.jsx)("p",{className:T,children:"O(\u03b1(n))"}),(0,W.jsx)("p",{className:H,children:"With path compression, amortized inverse Ackermann"})]}),(0,W.jsxs)("div",{className:R,children:[(0,W.jsx)("h4",{children:"Union"}),(0,W.jsx)("p",{className:T,children:"O(\u03b1(n))"}),(0,W.jsx)("p",{className:H,children:"With union by rank, amortized inverse Ackermann"})]}),(0,W.jsxs)("div",{className:R,children:[(0,W.jsx)("h4",{children:"Connected"}),(0,W.jsx)("p",{className:T,children:"O(\u03b1(n))"}),(0,W.jsx)("p",{className:H,children:"Two find operations"})]})]})]}),(0,W.jsxs)("div",{className:K,children:[(0,W.jsx)("h3",{children:"Real-World Applications:"}),(0,W.jsxs)("ul",{children:[(0,W.jsxs)("li",{children:[(0,W.jsx)("strong",{children:"Kruskal's Algorithm:"})," Minimum Spanning Tree - detect cycles efficiently"]}),(0,W.jsxs)("li",{children:[(0,W.jsx)("strong",{children:"Network Connectivity:"})," Check if two computers are connected in a network"]}),(0,W.jsxs)("li",{children:[(0,W.jsx)("strong",{children:"Image Processing:"})," Connected components labeling in images"]}),(0,W.jsxs)("li",{children:[(0,W.jsx)("strong",{children:"Social Networks:"})," Find groups of friends, detect communities"]}),(0,W.jsxs)("li",{children:[(0,W.jsx)("strong",{children:"Least Common Ancestor:"})," Finding LCA in trees using offline algorithms"]}),(0,W.jsxs)("li",{children:[(0,W.jsx)("strong",{children:"Game Development:"})," Dynamic connectivity in procedural generation"]})]}),(0,W.jsxs)("div",{className:V,children:[(0,W.jsx)("strong",{children:"Key Optimization:"})," Path compression flattens the tree structure during find operations, making subsequent operations nearly constant time. Union by rank ensures the shorter tree is attached under the taller one."]})]})]})}}}]);
//# sourceMappingURL=2576.27e454ad.chunk.js.map